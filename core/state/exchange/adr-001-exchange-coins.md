# ADR 001: Exchange Coins

## Coins With Reserve

### Bancor

todo

## Coins Without Reserve

Монеты с нулевым резервом могут использоваться брендами, которым не требуется обмен своих монет. Например, монета служит только расчетной единицей и может быть потрачена только в магазине той же торговой марки.

### Uniswap

#### Context

С помощью Uniswap можно будет мгновенно обменять любые монеты Minter (обычные, стейблкоины, монеты без резерва) на подарки и наоборот. Также появится возможность мгновенно обменивать монеты без резерва.

Также с помощью протокола Uniswap пользователи смогут оплачивать комиссию транзакции даже в монетах с нулевым резервом и стейблкоинах!

#### Decision

Создать модуль Exchanger по идеологии Uniswap. В котором, любой пользователь сможет создать или дополнить уже существующую ликвидность, такой пользователь будет называть поставщиком ликвидности.

##### Add

При создании пула для пары монет, в базу записывается структура по ключу _{xCoin,yCoin}_, **xCoin** и **yCoin** - идентификаторы монет в порядке возрастания. 
В пуле хранится общий объем пула по этим монетам с ключами _{xCoin,yCoin}_+_{xVolume}_ и _{xCoin,yCoin}_+_{yVolume}_ в байтовом представлении числа _bigInt_.
По ключам _{xCoin,yCoin}_+_{providerAddress}_+_{percent}_ хранится доля пула принадлежащая провайдеру с `providerAddress`.
При каждом новом добавлении ликвидности в пул, пересчитываются проценты существующих провайдеров и обновляются значения _{xCoin,yCoin}_+_{xVolume}_ и _{xCoin,yCoin}_+_{yVolume}_ объемов монет.

как хранится список провайдеров? нужно создать отдельный ключ с их списком?
хранить мапу и id для экономии? 

Метод для добавления ликвидности `Add` принимает в себя параметры:
 - provider types.Address - адрес поставщика,
 - xCoin types.CoinID - ID монеты Х для создания пары,
 - xVolume *big.Int - количество предоставляемых монет X для перерасчета или создания курса,
 - yCoin types.CoinID - ID монеты Y для создания пары, 
 - yVolume *big.Int - количество предоставляемых монет Y для перерасчета или создания курса.
 
```go
Add(provider types.Address, xCoin types.CoinID, xVolume *big.Int, yCoin types.CoinID, yVolume *big.Int) error
```

##### Couples

как они достаются из базы? при инициализации высоты? нужен ключ для хранения этого списка?

Метод для вывода всех уже имеющихся пар в пуле `Couples` возвращает массив таких пар с идентификаторами монет `xCoin` и `yCoin`.
```go
Couples() ([]*Couple, error)
```

##### Couple

Метод `Couples` для получения объема пула и цены, основанной на отношении количества монет в пуле по этой паре.
```go
Couple(xCoin types.CoinID, yCoin types.CoinID) (kVolume *big.Int, price *big.Float, err error)
```

##### Balance

Метод `Balance` принимает адрес поставщика ликвидности и монеты создающие пару. Возвращает процент доли поставщика в пуле пары и количество каждой из монет которые составляют его долу в пуле.
```go
Balance(provider types.Address, xCoin types.CoinID, yCoin types.CoinID) (volumes map[types.CoinID]*big.Int, percent *big.Float, err error)
```

##### Return

Метод для отзыва ликвидности из пула `Return` принимает адрес поставщика ликвидности, монеты создающие пару и произведение их количества, которое хочет забрать провайдер. Возвращает количество каждой монеты из запрошенной пары и вычитает их из пула. При этом идет перерасчет доли всех провайдеров относительно нового объема пула.
```go
Return(provider types.Address, xCoin types.CoinID, yCoin types.CoinID, kVolume *big.Int) (map[types.CoinID]*big.Int, error)
```

##### Exchange

Метод `Exchange` для обмена монет по курсу из Uniswap, принимает монеты `fromCoin` и `toCoin` между которыми хочет произвести обмен и ожидаемое количество монеты `toCoin`, получаемое по результату обмена. Обновляются только значения объемов в паре. Тк объем пула _x*y=k_ не изменится, провайдеры все так же имеют права на свой процент в пуле.  
```go
Exchange(fromCoin types.CoinID, toCoin types.CoinID, volume *big.Int, wantVolume *big.Int) (gotVolume *big.Int, err error)
```
